


> Written with [StackEdit](https://stackedit.io/).


## chapter05 数组
### 基础概念：
1. 线性表 & 非线性表
2. 连续的内存空间和相同类型的数据

### 数组插入和删除
1. 插入：在k位置插入数据，需要将后续的n-k个元素都移动一位
2. 删除：和插入类似，也需要搬运数据，但也可以在实现的时候先标记后删除，例如：JVM标记清除垃圾回收算法
3. 数组访问越界的问题
4. 容器 vs 数组

### 数组下标为什么从0开始
下标 == 偏移（offset）
所以a[k]的内存地址为：
a[k]_address = base_address + k * type_size

对于二维数组m * n
a[i][j]_address = base_address + (i * n + j) * type_size

## chapter06 链表1
### 单链表 vs 循环链表
删除操作：
* 删除结点中“值等于某个给定值”的结点：单链表和循环链表一致
* 删除给定指针指向的结点：在找到指定结点后，需要找到其前驱结点才能删除，双向链表会更高效

查找操作：
* 对于有序链表，双向链表的按值查询效率也要高一些。因为可以记录上次查找的位置p。例如：java中的LinkedHashMap

**用空间换时间的设计思路**：缓存

**LRU缓存淘汰算法**
维护一个有序的单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
1. 如果该数据之前已经被缓存过，那我们得到这个数据对应的结点，将其从原位置删除，然后插入到链表头部
2. 如果此数据没有在缓存链表中，：
	* 如果缓存未满，直接插入到头部
	* 如果缓存满了，则删除链表尾部的结点，将新的数据结点插入链表头部

**Q1. 用数组实现的LRU缓存淘汰算法**
**Q2. 字符串通过单链表来存储，如何判断是一个回文字符串**


## chapter07 链表2
### 几个写链表代码的技巧
1. 理解指针或者引用的含义
**将某个变量赋值给指针，实际上上将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量**

2. 警惕指针丢失和内存泄露
```c
// 指针丢失实例
p->next = x;  // 将 p 的 next 指针指向 x 结点；
x->next = p->next;  // 将 x 的结点的 next 指针指向 b 结点；
```
* 插入结点时，要注意操作顺序
* 删除结点时，也要注意手动释放内存空间

3. 利用哨兵家简化实现难度
* 针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理
* 引入哨兵结点，可以简化链表边界操作问题
* 带头链表
![](https://static001.geekbang.org/resource/image/7d/c7/7d22d9428bdbba96bfe388fe1e3368c7.jpg)

4. 重点留意边界条件处理
链表中常见边界条件：
* 如果链表为空，代码是否能正常工作
* 如果链表只包含一个结点，代码是否能正常工作
* 如果链表包含两个结点，代码是否能正常工作
* 代码逻辑在处理头结点和尾结点时，是否能正常工作

5. 举例画图，辅助思考
![](https://static001.geekbang.org/resource/image/4a/f8/4a701dd79b59427be654261805b349f8.jpg)

6. 多写多练，没有捷径
常见链表操作：
* 单链表反转
* 链表中环的检测
* 两个有序链表合并
* 删除链表倒数第n个结点
* 求链表的中间结点


<!--stackedit_data:
eyJoaXN0b3J5IjpbMjkzMjA3OTcxXX0=
-->