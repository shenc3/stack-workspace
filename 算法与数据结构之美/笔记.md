


> Written with [StackEdit](https://stackedit.io/).

## chapter01

为什么要学习算法与数据结构



## chapter02
### 20 个最常用的、最基础数据结构与算法
10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树
10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

### 学习技巧
1. 边学边练，适度刷题
2. 多问、多思考、多互动
3. 打怪升级学习法 —— 设定每节课的小目标
4. 只是需要沉淀，不要想试图一下子掌握所有


## chapter03 复杂度分析1

### 事后统计法的局限性
* 受测试环境影响
* 受数据规模影响

### 时间复杂度分析
1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 常见时间复杂度
![](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg)

## chapter04 复杂度分析2
复杂度分析的四种情况：
1. 最好情况时间复杂度（best case time complexity）
2. 最坏情况时间复杂度（worst case time complexity）
3. 平均情况时间复杂度（average case time complexity）
4. 均摊时间复杂度（amortized time complexity）

## chapter05 数组
### 基础概念：
1. 线性表 & 非线性表
2. 连续的内存空间和相同类型的数据

### 数组插入和删除
1. 插入：在k位置插入数据，需要将后续的n-k个元素都移动一位
2. 删除：和插入类似，也需要搬运数据，但也可以在实现的时候先标记后删除，例如：JVM标记清除垃圾回收算法
3. 数组访问越界的问题
4. 容器 vs 数组

### 数组下标为什么从0开始
下标 == 偏移（offset）
所以a[k]的内存地址为：
a[k]_address = base_address + k * type_size

对于二维数组m * n
a[i][j]_address = base_address + (i * n + j) * type_size

## chapter06 链表1
### 单链表 vs 循环链表
删除操作：
* 删除结点中“值等于某个给定值”的结点：单链表和循环链表一致
* 删除给定指针指向的结点：在找到指定结点后，需要找到其前驱结点才能删除，双向链表会更高效

查找操作：
* 对于有序链表，双向链表的按值查询效率也要高一些。因为可以记录上次查找的位置p。例如：java中的LinkedHashMap

**用空间换时间的设计思路**：缓存

**LRU缓存淘汰算法**
维护一个有序的单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
1. 如果该数据之前已经被缓存过，那我们得到这个数据对应的结点，将其从原位置删除，然后插入到链表头部
2. 如果此数据没有在缓存链表中，：
	* 如果缓存未满，直接插入到头部
	* 如果缓存满了，则删除链表尾部的结点，将新的数据结点插入链表头部

**Q1. 用数组实现的LRU缓存淘汰算法**
**Q2. 字符串通过单链表来存储，如何判断是一个回文字符串**


## chapter07 链表2
### 几个写链表代码的技巧
1. 理解指针或者引用的含义
**将某个变量赋值给指针，实际上上将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量**

2. 警惕指针丢失和内存泄露
```c
// 指针丢失实例
p->next = x;  // 将 p 的 next 指针指向 x 结点；
x->next = p->next;  // 将 x 的结点的 next 指针指向 b 结点；
```
* 插入结点时，要注意操作顺序
* 删除结点时，也要注意手动释放内存空间

3. 利用哨兵家简化实现难度
* 针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理
* 引入哨兵结点，可以简化链表边界操作问题
* 带头链表
![](https://static001.geekbang.org/resource/image/7d/c7/7d22d9428bdbba96bfe388fe1e3368c7.jpg)

4. 重点留意边界条件处理
链表中常见边界条件：
* 如果链表为空，代码是否能正常工作
* 如果链表只包含一个结点，代码是否能正常工作
* 如果链表包含两个结点，代码是否能正常工作
* 代码逻辑在处理头结点和尾结点时，是否能正常工作

5. 举例画图，辅助思考
![](https://static001.geekbang.org/resource/image/4a/f8/4a701dd79b59427be654261805b349f8.jpg)

6. 多写多练，没有捷径
常见链表操作：
* 单链表反转
* 链表中环的检测
* 两个有序链表合并
* 删除链表倒数第n个结点
* 求链表的中间结点


## chapter08 

### 理解栈
* 后进先出
* “栈”是一种“操作受限”的线性表，是对特定场景的抽象，数组或链表相对而言暴露了太多操作接口，操作上的确灵活自由，但使用时就比较不可控，也就更容易出错
* 顺序栈 & 链式栈

### 支持动态扩容的顺序栈
* 当栈满了以后，需要扩容，申请一块更大的内存，然后将原数组中的数据拷贝过去
![](https://static001.geekbang.org/resource/image/b1/da/b193adf5db4356d8ab35a1d32142b3da.jpg)
* 对于出栈来说，不涉及内存的重新申请和数据搬移，时间复杂度为O(1)
* 对于入栈来说，有空闲空间时，入栈操作时间复杂度为O(1)，当空间不够时，需要重新申请内存和数据搬移，时间复杂度变为O(n)
* 使用均摊法分析入栈操作的时间复杂度：
![](https://static001.geekbang.org/resource/image/c9/bb/c936a39ad54a9fdf526e805dc18cf6bb.jpg)
* 对于K次入栈操作，总共涉及K个数据搬移，以及K次push操作。所以入栈的均摊时间复杂度为O(1)

### 栈在函数调用中的应用
* main()函数中调用了一个add()函数
![](https://static001.geekbang.org/resource/image/17/1c/17b6c6711e8d60b61d65fb0df5559a1c.jpg)

### 其他应用
* 栈在表达式求解中的应用
* 栈在括号匹配中的应用
* 用两个栈来设计chrome前进、后退功能


## chapter09 队列
### 理解队列
* 先进先出
* 最基本的操作：入队enqueue()，出队dequeue()
* 运用的较多的是一些具有某些额外特性的队列：循环队列、阻塞队列、并发队列等

### 顺序队列和链式队列
* 用数组实现的叫做顺序队列，用链表实现的称为链式队列
* [顺序队列java实现]([https://gist.github.com/shenc3/0c9cb5d0ae279510412e6787a7916981](https://gist.github.com/shenc3/0c9cb5d0ae279510412e6787a7916981))
* [链式队列]([https://github.com/wangzheng0822/algo/blob/master/python/09_queue/linked_queue.py](https://github.com/wangzheng0822/algo/blob/master/python/09_queue/linked_queue.py))
* **循环队列**：队满条件(tail + 1) % n = head，队空条件head == tail

![](https://static001.geekbang.org/resource/image/3d/ec/3d81a44f8c42b3ceee55605f9aeedcec.jpg)

### 阻塞队列和并发队列
**阻塞队列**：在队列的基础上加了阻塞操作，即队列为空时，从队头取数据会被阻塞，因为此时没有数据可以取，直到队列中有数据才能返回；队列已经满时，插入数据的操作会被阻塞。
![](https://static001.geekbang.org/resource/image/5e/eb/5ef3326181907dea0964f612890185eb.jpg)

**并发队列**：线程安全的队列。最简单的实现方法是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作

### 线程池
* 有界队列 vs 无界队列


## chapter10 递归
### 理解递归
所有的递归问题都可以用递推公式来表示

### 递归需要满足的三个条件
1. **一个问题的解可以分解为几个子问题的解**
2. **这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样**
3. **存在递归终止条件**

### 如何编写递归代码
**写成递归公式，找到终止条件**



<!--stackedit_data:
eyJoaXN0b3J5IjpbMTg5NTEwMjgsMzEwMjkwOTcsMTc4ODMyMj
A2Niw1NjI0NTI1NTEsMTAzNDEwNTcxMCwzNTYyMjU3MjAsLTEx
MTMwNTc4OTksLTE0NjcwMjM4NDEsLTc1ODY0MzY1LC0xMzc1Mj
Q4MzEyLDcwMzExMDIzMl19
-->