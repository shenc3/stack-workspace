


> Written with [StackEdit](https://stackedit.io/).

## chapter01

为什么要学习算法与数据结构



## chapter02
### 20 个最常用的、最基础数据结构与算法
10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie树
10个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法

### 学习技巧
1. 边学边练，适度刷题
2. 多问、多思考、多互动
3. 打怪升级学习法 —— 设定每节课的小目标
4. 只是需要沉淀，不要想试图一下子掌握所有


## chapter03 | 复杂度分析1

### 事后统计法的局限性
* 受测试环境影响
* 受数据规模影响

### 时间复杂度分析
1. 只关注循环执行次数最多的一段代码
2. 加法法则：总复杂度等于量级最大的那段代码的复杂度
3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积

### 常见时间复杂度
![](https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg)

## chapter04 | 复杂度分析2
复杂度分析的四种情况：
1. 最好情况时间复杂度（best case time complexity）
2. 最坏情况时间复杂度（worst case time complexity）
3. 平均情况时间复杂度（average case time complexity）
4. 均摊时间复杂度（amortized time complexity）

## chapter05 数组
### 基础概念：
1. 线性表 & 非线性表
2. 连续的内存空间和相同类型的数据

### 数组插入和删除
1. 插入：在k位置插入数据，需要将后续的n-k个元素都移动一位
2. 删除：和插入类似，也需要搬运数据，但也可以在实现的时候先标记后删除，例如：JVM标记清除垃圾回收算法
3. 数组访问越界的问题
4. 容器 vs 数组

### 数组下标为什么从0开始
下标 == 偏移（offset）
所以a[k]的内存地址为：
a[k]_address = base_address + k * type_size

对于二维数组m * n
a[i][j]_address = base_address + (i * n + j) * type_size

## chapter06 链表1
### 单链表 vs 循环链表
删除操作：
* 删除结点中“值等于某个给定值”的结点：单链表和循环链表一致
* 删除给定指针指向的结点：在找到指定结点后，需要找到其前驱结点才能删除，双向链表会更高效

查找操作：
* 对于有序链表，双向链表的按值查询效率也要高一些。因为可以记录上次查找的位置p。例如：java中的LinkedHashMap

**用空间换时间的设计思路**：缓存

**LRU缓存淘汰算法**
维护一个有序的单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头开始顺序遍历链表。
1. 如果该数据之前已经被缓存过，那我们得到这个数据对应的结点，将其从原位置删除，然后插入到链表头部
2. 如果此数据没有在缓存链表中，：
	* 如果缓存未满，直接插入到头部
	* 如果缓存满了，则删除链表尾部的结点，将新的数据结点插入链表头部

**Q1. 用数组实现的LRU缓存淘汰算法**
**Q2. 实**

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTAzOTA2ODY4LC0xMTEzMDU3ODk5LC0xND
Y3MDIzODQxLC03NTg2NDM2NSwtMTM3NTI0ODMxMiw3MDMxMTAy
MzJdfQ==
-->