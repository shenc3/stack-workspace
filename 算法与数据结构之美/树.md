


> Written with [StackEdit](https://stackedit.io/).

[代码实现](https://github.com/shenc3/beauty-of-algo/blob/master/chapter24-tree.py)

## chapter23 二叉树1

### 树
**基本概念**
* 节点，父节点，子节点，兄弟节点，根节点，叶子节点
* 高度（Height）：节点到叶子节点的最长路径（边数）
* 深度（Depth）：根节点到这个节点所经历的边的个数
* 层（Level）：节点的深度 + 1
* 树的高度 = 根节点的高度

### 二叉树
* 几种特殊二叉树：满二叉树，完全二叉树
* 存储方法：
	* 基于指针或引用的二叉链表存储法
	* ![](https://static001.geekbang.org/resource/image/12/8e/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg)
	* 基于数组的顺序存储法
	* ![](https://static001.geekbang.org/resource/image/14/30/14eaa820cb89a17a7303e8847a412330.jpg)
	* 如果树是一棵完全二叉树，那用数组存储无疑是最节省内存的一种方法；否则，会造成存储空间的浪费

### 二叉树遍历

![](https://static001.geekbang.org/resource/image/ab/16/ab103822e75b5b15c615b68560cb2416.jpg)

* 给定一组数据，可以构建多少种不同的二叉树
* 按层遍历


## chapter24 二叉树2

### 二叉搜索树

* 定义：二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值
* 查找操作：
* 插入操作：
* 删除操作：
* 其他操作：快速地查找最大节点和最小节点、前驱节点和后继节点
* 支持重复数据的二叉查找树
	* 方法一：每一个节点存储多个数据
	* 方法二：每个节点只存储一个数据，在插入过程中碰到相同的值，将其放在右子树
		* 插入操作：
		* ![](https://static001.geekbang.org/resource/image/3f/5f/3f59a40e3d927f567022918d89590a5f.jpg)
		* 查找操作：找到目标值节点时不停止查找操作，而是继续在其右子树中查找，直到遇到叶子节点
		* ![](https://static001.geekbang.org/resource/image/fb/ff/fb7b320efd59a05469d6d6fcf0c98eff.jpg)
		* 删除操作：需要先查找到每个要删除的节点，然后依次删除
		* ![](https://static001.geekbang.org/resource/image/25/17/254a4800703d31612c0af63870260517.jpg)

* 


## chapter25 红黑树1
#### 定义

红黑树的节点，一类被标记为黑色，一类被标记为红色。除此之外：
* 根节点是黑色的
* 每个叶子节点都是黑色的空节点（NIL），也即是说，叶子节点不存储数据
* 任何相邻的节点都不能同时为红色，也就是说，红色节点被黑色节点隔开了
* 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点

#### 其他动态数据结构
* [ ] 链表
* [ ] 栈
* [ ] 队列
* [x] 红黑树
* [x] 跳表


<!--stackedit_data:
eyJoaXN0b3J5IjpbLTc1NjI4OTc4MywtMTg5NjMzNzc2OCwtMT
AxMzIxNjExLC05ODQ5OTQ3MjEsLTE4NDkxMTg1NDksLTE2MzQw
NjczOTJdfQ==
-->