


> Written with [StackEdit](https://stackedit.io/).

## chapter28 堆和堆排序
### 定义

* 堆是一个完全二叉树
* 堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值
* “大顶堆” vs “小顶堆”

### 堆的存储
可以使用数组来存储堆，数组中下标为i的节点其左右节点分别为2 * i和2 * i + 1，其父节点为 i / 2
![](https://static001.geekbang.org/resource/image/4d/1e/4d349f57947df6590a2dd1364c3b0b1e.jpg)


### 堆支持的操作

1. 往堆中插入一个元素
	* 从下往上**堆化**
	* ![](https://static001.geekbang.org/resource/image/e3/0e/e3744661e038e4ae570316bc862b2c0e.jpg)
2. 删除堆顶元素
	* 从上往下**堆化**
	* ![](https://static001.geekbang.org/resource/image/11/60/110d6f442e718f86d2a1d16095513260.jpg)

### 堆排序
#### 1. 建堆
* **思路1**：从第一个元素开始，依次将元素插入一个堆，即**从下往上**堆化
* **思路2**：从第一个叶子节点开始，依次将中间节点**从上往下**堆化
![](https://static001.geekbang.org/resource/image/50/1e/50c1e6bc6fe68378d0a66bdccfff441e.jpg)
* 从叶子节点开始堆化的时间复杂度为O(n)

#### 2. 排序
堆顶元素与arr[n]交换 --> 堆化 --> 堆顶元素与arr[n-1]交换 --> 堆化 --> ... --> 只剩1个元素
![](https://static001.geekbang.org/resource/image/23/d1/23958f889ca48dbb8373f521708408d1.jpg)

### 堆排序 vs 快速排序
1. 对快速排序来说，数据是顺序访问的，而堆排序，数据是跳着访问的，对CPU缓存不是很友好
2. 对于同样的数据，堆排序的数据交换次数要多于快速排序

## chapter29 堆的应用

<!--stackedit_data:
eyJoaXN0b3J5IjpbMTI5MTMxNjA5OCwtMTY3MjU1MTkzMCwxMz
c3NTgzMjA1LDcwNDIwMTQ5NCwtNTk3ODg4NDgxLDEwNDc1Mjcy
Myw4OTA0NjM3MDUsLTQwNjk2MjI4NSwtOTk5NDk2NDMyXX0=
-->